prog1
program ArithmeticTest {
    int main() {
        int a = 10
        int b = 5
        int result = (a + b) * (a - b) / 2
        return result
    }
}

result1
.386
.model flat, stdcall
option casemap :none

include \\masm32\\include\\windows.inc
include \\masm32\\include\\kernel32.inc
include \\masm32\\include\\masm32.inc
includelib \\masm32\\lib\\kernel32.lib
includelib \\masm32\\lib\\masm32.lib

.data

.code
start:
call main
invoke ExitProcess, 0

main PROC
push ebp
mov ebp, esp
sub esp, 12

; int a = 10
mov eax, 10
mov [ebp-4], eax

; int b = 5
mov eax, 5
mov [ebp-8], eax

; result = (a + b) * (a - b) / 2

; حساب (a + b)
mov eax, [ebp-4]
push eax
mov eax, [ebp-8]
pop ebx
add eax, ebx
push eax

; حساب (a - b)
mov eax, [ebp-4]
push eax
mov eax, [ebp-8]
pop ebx
sub eax, ebx

; (a + b) * (a - b)
pop ebx
imul eax, ebx
push eax

; / 2
mov eax, 2
pop ebx
xor edx, edx
xchg eax, ebx
idiv ebx
mov eax, ebx

; تخزين النتيجة
mov [ebp-12], eax

; return result
mov eax, [ebp-12]

mov esp, ebp
pop ebp
ret
main ENDP

end start

prog2
program LoopTest {
    int main() {
        int sum = 0
        for (int i = 1 ; i <= 10; i = i + 1) {
            if (i % 2 == 0) {
                sum = sum + i
            }
        }
        return sum
    }
}

result2
.386
.model flat, stdcall
option casemap :none

include \\masm32\\include\\windows.inc
include \\masm32\\include\\kernel32.inc
include \\masm32\\include\\masm32.inc
includelib \\masm32\\lib\\kernel32.lib
includelib \\masm32\\lib\\masm32.lib

.data

.code
start:
call main
invoke ExitProcess, 0

main PROC
push ebp
mov ebp, esp
sub esp, 12

; int sum = 0
mov eax, 0
mov [ebp-4], eax

; int i = 1
mov eax, 1
mov [ebp-8], eax

L_for_start_0:
; i <= 10
mov eax, [ebp-8]
push eax
mov eax, 10
pop ebx
cmp ebx, eax
setle al
movzx eax, al
cmp eax, 0
je L_for_end_0

; if (i % 2 == 0)
; حساب i % 2
mov eax, [ebp-8]
push eax
mov eax, 2
pop ebx
xor edx, edx
xchg eax, ebx
idiv ebx
mov eax, edx
; المقارنة مع 0
push eax
mov eax, 0
pop ebx
cmp ebx, eax
sete al
movzx eax, al
cmp eax, 0
je L_else_0

; sum = sum + i
mov eax, [ebp-4]
push eax
mov eax, [ebp-8]
pop ebx
add eax, ebx
mov [ebp-4], eax

L_else_0:
; i = i + 1
mov eax, [ebp-8]
push eax
mov eax, 1
pop ebx
add eax, ebx
mov [ebp-8], eax

jmp L_for_start_0
L_for_end_0:

; return sum
mov eax, [ebp-4]

mov esp, ebp
pop ebp
ret
main ENDP

end start

prog3
program FunctionTest {
    int factorial(int n) {
        if (n <= 1) {
            return 1
        }
        return n * factorial(n - 1)
    }

    int main() {
        int result = factorial(5)
        return result
    }
}

result3
.386
.model flat, stdcall
option casemap :none

include \\masm32\\include\\windows.inc
include \\masm32\\include\\kernel32.inc
include \\masm32\\include\\masm32.inc
includelib \\masm32\\lib\\kernel32.lib
includelib \\masm32\\lib\\masm32.lib

.data

.code
start:
call main
invoke ExitProcess, 0

factorial PROC
push ebp
mov ebp, esp
; Parameter: n at [ebp+8]

; if (n <= 1)
mov eax, [ebp+8]
cmp eax, 1
jg L_recursive_case

; return 1
mov eax, 1
jmp L_end_factorial

L_recursive_case:
; return n * factorial(n - 1)
; حساب n - 1
mov eax, [ebp+8]
sub eax, 1

; استدعاء factorial(n - 1)
push eax
call factorial
add esp, 4

; n * factorial(n - 1)
mov ebx, [ebp+8]
imul eax, ebx

L_end_factorial:
mov esp, ebp
pop ebp
ret
factorial ENDP

main PROC
push ebp
mov ebp, esp
sub esp, 4

; result = factorial(5)
push 5
call factorial
add esp, 4

mov [ebp-4], eax       ; ✅ الإزاحة الصحيحة الآن

                       ; return result
mov eax, [ebp-4]

mov esp, ebp
pop ebp
ret
main ENDP

end start

prog4
program GlobalTest {
    int counter = 0

    int increment() {
        counter = counter + 1
        return counter
    }

    int main() {
        int a = increment()
        int b = increment()
        return a + b
    }
}

result4
.386
.model flat, stdcall
option casemap :none

include \\masm32\\include\\windows.inc
include \\masm32\\include\\kernel32.inc
include \\masm32\\include\\masm32.inc
includelib \\masm32\\lib\\kernel32.lib
includelib \\masm32\\lib\\masm32.lib

.data
counter DWORD 0

.code
start:
call main
invoke ExitProcess, 0

increment PROC
push ebp
mov ebp, esp

; Expression: counter = counter + 1
; Complex assignment: counter = ...
; Expression: counter + 1
; Binary operation: +
; Expression: counter
; Load variable: counter
mov eax, counter
push eax
; Expression: 1
mov eax, 1
pop ebx
add eax, ebx
mov counter, eax       ; ✅ الآن يتم تخزين counter + 1

                       ; Expression: counter
                       ; Load variable: counter
mov eax, counter       ; ✅ إرجاع القيمة الجديدة

mov esp, ebp
pop ebp
ret
increment ENDP

main PROC
push ebp
mov ebp, esp
sub esp, 8

; Expression: increment()
; Call function: increment
call increment
mov [ebp-4], eax       ; a = 1

                       ; Expression: increment()
                       ; Call function: increment
call increment
mov [ebp-8], eax       ; b = 2

                       ; Expression: a + b
                       ; Binary operation: +
                       ; Expression: a
                       ; Load variable: a
mov eax, [ebp-4]
push eax
; Expression: b
; Load variable: b
mov eax, [ebp-8]
pop ebx
add eax, ebx           ; ✅ النتيجة: 1 + 2 = 3

mov esp, ebp
pop ebp
ret
main ENDP

end start

prog5
program StructTest {
    struct MathConstants {
        static double PI = 3.14159
        static double E = 2.71828
    }

    double circleArea(double radius) {
        return MathConstants.PI * radius * radius
    }

    int main() {
        double area = circleArea(5.0)
        return (int)area
    }
}

result5
.386
.model flat, stdcall
option casemap :none

include \\masm32\\include\\windows.inc
include \\masm32\\include\\kernel32.inc
include \\masm32\\include\\masm32.inc
includelib \\masm32\\lib\\kernel32.lib
includelib \\masm32\\lib\\masm32.lib

.data
PI REAL8 3.14159
E REAL8 2.71828

.code
start:
call main
invoke ExitProcess, 0

circleArea PROC
push ebp
mov ebp, esp

; Expression: MathConstants.PI * radius * radius
; Floating point operation: *
; Expression: MathConstants.PI * radius
; Floating point operation: *
; Expression: MathConstants.PI
; Struct member access: MathConstants.PI
fld PI                 ; ✅ تحميل PI كقيمة عائمة
                       ; Expression: radius
                       ; Load variable: radius
fld qword ptr [ebp+8]  ; ✅ تحميل radius كقيمة عائمة
fmulp st(1), st(0)     ; ✅ ضرب عائم: PI * radius
                       ; Expression: radius
                       ; Load variable: radius
fld qword ptr [ebp+8]  ; ✅ تحميل radius مرة أخرى
fmulp st(1), st(0)     ; ✅ ضرب عائم: (PI * radius) * radius

mov esp, ebp
pop ebp
ret
circleArea ENDP

main PROC
push ebp
mov ebp, esp
sub esp, 8

; Expression: circleArea(5.0)
; Call function: circleArea
; Expression: 5.0
push __float32__(5.0)  ; ✅ تحميل 5.0
fld dword ptr [esp]
add esp, 4
sub esp, 8             ; ✅ تخصيص مساحة لـ double
fstp qword ptr [esp]   ; ✅ تخزين كـ double في المكدس
call circleArea
add esp, 8             ; ✅ تنظيف مكدس المعاملات

                       ; تخزين النتيجة
fstp qword ptr [ebp-8] ; ✅ تخزين النتيجة في area

                       ; return area
fld qword ptr [ebp-8]  ; ✅ تحميل area للإرجاع

mov esp, ebp
pop ebp
ret
main ENDP

end start

prog6
program LogicTest {
    int findMax(int a, int b, int c) {
        int max = a
        if (b > max) {
            max = b
        }
        if (c > max) {
            max = c
        }
        return max
    }

    int main() {
        int result = findMax(10, 25, 15)
        return result
    }
}

result6
.386
.model flat, stdcall
option casemap :none

include \\masm32\\include\\windows.inc
include \\masm32\\include\\kernel32.inc
include \\masm32\\include\\masm32.inc
includelib \\masm32\\lib\\kernel32.lib
includelib \\masm32\\lib\\masm32.lib

.data

.code
start:
call main
invoke ExitProcess, 0

findMax PROC
push ebp
mov ebp, esp
sub esp, 4

; int max = a
mov eax, [ebp+8]
mov [ebp-4], eax

; if (b > max)
mov eax, [ebp+12]
cmp eax, [ebp-4]
jle L_endif_0

; max = b
mov eax, [ebp+12]
mov [ebp-4], eax

L_endif_0:
; if (c > max)
mov eax, [ebp+16]
cmp eax, [ebp-4]
jle L_endif_1

; max = c
mov eax, [ebp+16]
mov [ebp-4], eax

L_endif_1:
; return max
mov eax, [ebp-4]

mov esp, ebp
pop ebp
ret
findMax ENDP

main PROC
push ebp
mov ebp, esp
sub esp, 4

; findMax(10, 25, 15)
push 15
push 25
push 10
call findMax
add esp, 12

mov [ebp-4], eax

; return result
mov eax, [ebp-4]

mov esp, ebp
pop ebp
ret
main ENDP

end start

prog7
program ArrayTest {
    int main() {
        int arr[3]
        arr[0] = 1
        arr[1] = 2
        arr[2] = arr[0] + arr[1]
        return arr[2]
    }
}

result7
.386
.model flat, stdcall
option casemap :none

include \\masm32\\include\\windows.inc
include \\masm32\\include\\kernel32.inc
include \\masm32\\include\\masm32.inc
includelib \\masm32\\lib\\kernel32.lib
includelib \\masm32\\lib\\masm32.lib

.data

.code
start:
call main
invoke ExitProcess, 0

main PROC
push ebp
mov ebp, esp
sub esp, 12

; arr[0] = 1
mov eax, 1
mov [ebp-4], eax

; arr[1] = 2
mov eax, 2
mov [ebp-8], eax

; arr[2] = arr[0] + arr[1]
mov eax, [ebp-4]
add eax, [ebp-8]
mov [ebp-12], eax

; return arr[2]
mov eax, [ebp-12]

mov esp, ebp
pop ebp
ret
main ENDP

end start